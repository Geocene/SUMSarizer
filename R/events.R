#' Number Events
#' 
#' Generate unique identifiers for each event, based on indicator of being in an event.
#' Nonevent periods are labelled NA
#' @param label A binary vector, where TRUE indicates an event
#' @export
number_events <- function(label){
  runs <- rle(label)
  runs$values = ifelse(runs$values == T, cumsum(runs$values), NA)
  event_nums = inverse.rle(runs)
  return(event_nums)
}


#' Smooth Events
#' 
#' Reduce "blipiness" in event indicators by eliminating small cooking events and gaps
#' @param label A binary vector, where TRUE indicates an event
#' @param sample_interval the sample interval in seconds
#' @param min_event_sec minmum number of seconds in a real event
#' @param min_break_sec minmum number of seconds in a real non-event
#' @export
smooth_events <- function(label, sample_interval, min_event_sec = 5*60, min_break_sec = 30 * 60){
  
  rl_obj <- rle(label)
  
  #remove short breaks between cooking
  rl_obj$values[(rl_obj$lengths * sample_interval) < min_break_sec & rl_obj$values == F] = T
  label <- inverse.rle(rl_obj)
  
  #remove short cooking events
  rl_obj2 <- rle(label)
  rl_obj2$values[(rl_obj2$lengths * sample_interval) < min_event_sec & rl_obj2$values == T] = F
  label <- inverse.rle(rl_obj2)
  
  return(label)
}


#' Summarize Events
#' 
#' Generate basic event summaries
#' @param event_num an event identifer as generated by \link{number_events}
#' @param sample_interval the sample interval in seconds
#' @export
summarize_events <- function(event_num, sample_interval_secs){
  nevents <- length(unique(event_num[!is.na(event_num)]))
  duration <- sum((!is.na(event_num))*sample_interval_secs)/60
  return(list(nevents=nevents,duration=duration))
}


list_events <- function(labeled_data){
    sample_interval_sec = est_sample_interval(labeled_data$timestamp)

    events = labeled_data %>%
      group_by(event_num) %>%
      summarise(
        start_time = min(timestamp, na.rm = T),
        stop_time = max(timestamp, na.rm = T),
        duration_mins = (as.numeric(difftime(stop_time, start_time, unit='secs')) + sample_interval_sec)/60,
        min_temp = min(value, na.rm = T),
        max_temp = max(value, na.rm = T),
        kind_id = 'cooking',
        created_at = strftime(Sys.time() , "%Y-%m-%dT%H:%M:%S%z")
      )

    events = events[complete.cases(events[, 1]), ]
    return(events)  
}
